<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ashta Chemma - ‡∞Ö‡∞∑‡±ç‡∞ü‡∞æ ‡∞ö‡∞Æ‡±ç‡∞Æ‡∞æ</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        .container { width: 100%; height: 100%; display: flex; flex-direction: column; }
        
        /* 3% Header: 80% title + 20% menu */
        .header-row {
            height: 3vh;
            display: flex;
            background: rgba(255,255,255,0.95);
        }
        .game-title {
            width: 80%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: bold;
            font-size: 1.8vh;
            border-right: 2px solid #ddd;
        }
        .menu-container {
            width: 20%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        .menu-icon {
            display: flex;
            flex-direction: column;
            gap: 0.3vh;
            cursor: pointer;
        }
        .menu-line {
            width: 3vw;
            height: 0.3vh;
            background: #667eea;
            border-radius: 2px;
            transition: all 0.3s;
        }
        .menu-icon:hover .menu-line { background: #764ba2; }
        
        /* 2% Dead pieces revival */
        .dead-revival-row {
            height: 2vh;
            background: #fff3cd;
            border-bottom: 2px solid #ffc107;
            display: none;
            align-items: center;
            justify-content: center;
            gap: 2%;
        }
        .dead-revival-row.show { display: flex; }
        .revival-btn {
            width: 30%;
            height: 1.4vh;
            background: #90EE90;
            border: 2px solid #4CAF50;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2vh;
            color: #333;
        }
        .revival-btn:hover { background: #7CFC00; }
        
        /* 20% Controls */
        .controls-row {
            height: 20vh;
            display: flex;
            background: white;
        }
        .turn-section, .dice-section {
            width: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1vh;
        }
        .turn-section {
            border-right: 2px solid #e0e0e0;
            justify-content: center;
        }
        .turn-section h3 { font-size: 2.4vh; margin-bottom: 1vh; }
        .turn-info { font-size: 1.6vh; text-align: center; }
        
        .dice-section {
            justify-content: flex-start;
            gap: 0.5vh;
        }
        .roll-btn {
            width: 40%;
            height: 3vh;
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: clamp(10px, 1.4vh, 20px);
        }
        .roll-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .seeds {
            position: relative;
            width: 45%;
            height: 15vh;
            aspect-ratio: 1/1;
            background: radial-gradient(circle, #8b7355 0%, #6b5644 100%);
            border-radius: 50%;
            box-shadow: inset 0 2px 8px rgba(0,0,0,0.4);
        }
        .seed {
            width: 18%;
            height: 25%;
            position: absolute;
            background-size: contain;
            background-repeat: no-repeat;
        }
        .seed.white { background-image: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZGVmcz4KICAgIDxyYWRpYWxHcmFkaWVudCBpZD0id2hpdGVHcmFkIiBjeD0iNTAlIiBjeT0iNDAlIj4KICAgICAgPHN0b3Agb2Zmc2V0PSIwJSIgc3R5bGU9InN0b3AtY29sb3I6I2ZmZmZmZjtzdG9wLW9wYWNpdHk6MSIgLz4KICAgICAgPHN0b3Agb2Zmc2V0PSI1MCUiIHN0eWxlPSJzdG9wLWNvbG9yOiNmNWY1ZTg7c3RvcC1vcGFjaXR5OjEiIC8+CiAgICAgIDxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6I2UwZTBkMDtzdG9wLW9wYWNpdHk6MSIgLz4KICAgIDwvcmFkaWFsR3JhZGllbnQ+CiAgPC9kZWZzPgogIDxlbGxpcHNlIGN4PSI1MCIgY3k9IjYwIiByeD0iNDIiIHJ5PSI1NSIgZmlsbD0idXJsKCN3aGl0ZUdyYWQpIiBzdHJva2U9IiNjMGMwYjAiIHN0cm9rZS13aWR0aD0iMiIvPgo8L3N2Zz4='); }
        .seed.black { background-image: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZGVmcz4KICAgIDxyYWRpYWxHcmFkaWVudCBpZD0iYnJvd25HcmFkIiBjeD0iNTAlIiBjeT0iNDAlIj4KICAgICAgPHN0b3Agb2Zmc2V0PSIwJSIgc3R5bGU9InN0b3AtY29sb3I6IzZiNGUzZjtzdG9wLW9wYWNpdHk6MSIgLz4KICAgICAgPHN0b3Agb2Zmc2V0PSI1MCUiIHN0eWxlPSJzdG9wLWNvbG9yOiM1YTNlMmY7c3RvcC1vcGFjaXR5OjEiIC8+CiAgICAgIDxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6IzRhMmUxZjtzdG9wLW9wYWNpdHk6MSIgLz4KICAgIDwvcmFkaWFsR3JhZGllbnQ+CiAgPC9kZWZzPgogIDxlbGxpcHNlIGN4PSI1MCIgY3k9IjYwIiByeD0iNDIiIHJ5PSI1NSIgZmlsbD0idXJsKCNicm93bkdyYWQpIiBzdHJva2U9IiMzYTJlMWYiIHN0cm9rZS13aWR0aD0iMiIvPgo8L3N2Zz4='); }
        .dice-result { font-size: 1.4vh; font-weight: bold; color: #667eea; }
        
        /* 5% Status messages: 2x2 grid */
        .status-row {
            height: 5vh;
            display: grid;
            grid-template-columns: 50% 50%;
            grid-template-rows: 50% 50%;
            background: white;
            border-top: 2px solid #e0e0e0;
        }
        .status-cell {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1vh;
            font-weight: bold;
            padding: 0 1%;
            text-align: center;
            overflow: hidden;
        }
        .status-cell.accumulated { background: #e8f5e9; color: #2e7d32; border-right: 1px solid #ddd; border-bottom: 1px solid #ddd; }
        .status-cell.turn-sum { background: #e3f2fd; color: #1976d2; border-bottom: 1px solid #ddd; }
        .status-cell.remaining { background: #fff3cd; color: #856404; border-right: 1px solid #ddd; }
        .status-cell.message { background: #ffe4e1; color: #d32f2f; }
        
        /* 50% Board */
        .board-row {
            height: 50vh;
            width: 100%;
            background: rgba(255,255,255,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1vh 2vw;
        }
        .board {
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(5, 20%);
            grid-template-rows: repeat(5, 20%);
            gap: 0.2%;
            background: #333;
            padding: 0.5%;
            border: 4px solid #333;
            border-radius: 10px;
        }
        .cell {
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
        }
        .cell.safe { background: linear-gradient(135deg, #ffd89b 0%, #19547b 100%); }
        .cell.safe::before { content: 'X'; position: absolute; font-size: 4vh; color: rgba(255,255,255,0.3); font-weight: bold; }
        .cell.win { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
        .cell.valid-dest { box-shadow: inset 0 0 0 3px #2196F3; animation: blink 1s infinite; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        
        .pieces-on-cell { display: grid; grid-template-columns: repeat(3, 1fr); gap: 2%; width: 90%; height: 90%; pointer-events: none; }
        .piece {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 2px solid white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9vh;
            color: white;
            font-weight: bold;
            cursor: pointer;
            pointer-events: auto;
            position: relative;
        }
        .piece::before {
            content: '';
            position: absolute;
            top: -30%;
            left: -30%;
            right: -30%;
            bottom: -30%;
            cursor: pointer;
        }
        .piece.parent { border-width: 3px; font-size: 1.2vh; }
        .piece.selectable { border-color: #4CAF50; box-shadow: 0 0 8px #4CAF50; }
        .team-color-0 { background: #e74c3c; }
        .team-color-1 { background: #3498db; }
        .team-color-2 { background: #2ecc71; }
        .team-color-3 { background: #f39c12; }
        
        /* 3% Footer */
        .footer {
            height: 3vh;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: clamp(8px, 1.2vh, 14px);
            border-top: 2px solid rgba(255,255,255,0.2);
            padding: 0 2vw;
            text-align: center;
            flex-wrap: wrap;
        }
        
        /* Modals 90% x 95% */
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 9999; align-items: center; justify-content: center; }
        .modal.show { display: flex; }
        .modal-content {
            background: white;
            width: 90vw;
            height: 95vh;
            border-radius: 15px;
            position: relative;
            overflow-y: auto;
            padding: 3%;
        }
        .modal-content.win-modal {
            width: 60vw;
            height: auto;
            max-height: 60vh;
            padding: 5vh;
        }
        .modal-close {
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 5vh;
            cursor: pointer;
            color: #666;
            line-height: 1;
            z-index: 10;
        }
        .modal-close:hover { color: #000; }
        .modal h2 { font-size: 3vh; margin-bottom: 2vh; }
        .modal ul { margin: 2vh; line-height: 2; font-size: 2vh; }
        .modal li { margin-bottom: 1vh; }
        
        .setup-screen { 
            background: white; 
            padding: 3vh 5vw; 
            border-radius: 20px; 
            max-width: 90vw;
            max-height: 90vh;
            margin: 5vh auto;
            display: flex;
            flex-direction: column;
        }
        .setup-screen h1 { 
            text-align: center; 
            color: #333; 
            margin-bottom: 3vh; 
            font-size: 3vh;
        }
        .form-group { margin-bottom: 2vh; }
        .form-group label { 
            display: block; 
            margin-bottom: 1vh; 
            color: #333; 
            font-weight: bold; 
            font-size: 1.8vh;
        }
        .form-group input { 
            width: 100%; 
            padding: 1.5vh; 
            border: 2px solid #e0e0e0; 
            border-radius: 8px; 
            font-size: 1.8vh;
        }
        .team-setup { 
            margin-top: 2vh; 
            padding: 2vh; 
            background: #f8f9fa; 
            border-radius: 10px; 
            max-height: 40vh;
            overflow-y: auto;
            flex-shrink: 1;
        }
        .team-item { 
            margin-bottom: 2vh; 
            padding: 2vh; 
            background: white; 
            border-radius: 8px; 
        }
        .team-item h4 {
            font-size: 2vh;
            margin-bottom: 1vh;
        }
        .team-item input {
            width: 100%;
            padding: 1.2vh;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            font-size: 1.6vh;
            margin-top: 1vh;
        }
        .setup-screen button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white; 
            padding: 2vh 4vw; 
            border: none; 
            border-radius: 8px;
            font-size: 2vh; 
            width: 100%; 
            margin-top: 2vh; 
            font-weight: bold; 
            cursor: pointer;
        }
        .setup-screen button:hover { opacity: 0.9; }
        .setup-screen button:disabled { opacity: 0.5; cursor: not-allowed; }
        .hidden { display: none !important; }
        .setup-screen h1 { text-align: center; color: #333; margin-bottom: 30px; }
    </style>
</head>
<body>
    <div class="container">
        <!-- Setup Screen -->
        <div class="setup-screen" id="setupScreen">
            <h1>Ashta Chemma - ‡∞Ö‡∞∑‡±ç‡∞ü‡∞æ ‡∞ö‡∞Æ‡±ç‡∞Æ‡∞æ</h1>
            <div class="form-group">
                <label>Number of Teams (2-4):</label>
                <input type="number" id="numTeams" min="2" max="4" value="2">
            </div>
            <div class="form-group">
                <label>Players per Team (1-2, same for all):</label>
                <input type="number" id="playersPerTeam" min="1" max="2" value="1">
            </div>
            <button onclick="generateTeamInputs()">Next</button>
            
            <div class="team-setup hidden" id="teamSetup"></div>
            <button class="hidden" id="startBtn" onclick="startGame()">Start Game</button>
        </div>

        <!-- Game Screen -->
        <div class="container hidden" id="gameScreen">
            <!-- 3% Header -->
            <div class="header-row">
                <div class="game-title">Ashta Chemma - ‡∞Ö‡∞∑‡±ç‡∞ü‡∞æ ‡∞ö‡∞Æ‡±ç‡∞Æ‡∞æ</div>
                <div class="menu-container" onclick="openMenuModal()">
                    <div class="menu-icon">
                        <div class="menu-line"></div>
                        <div class="menu-line"></div>
                        <div class="menu-line"></div>
                    </div>
                </div>
            </div>
            
            <!-- 2% Dead Revival -->
            <div class="dead-revival-row" id="deadRevivalRow"></div>
            
            <!-- 20% Controls -->
            <div class="controls-row">
                <div class="turn-section">
                    <h3>Current Turn</h3>
                    <div class="turn-info" id="currentTurnInfo"></div>
                </div>
                <div class="dice-section">
                    <button class="roll-btn" onclick="rollDice()" id="rollBtn">‡∞™‡∞ø‡∞ï‡±ç‡∞ï‡∞≤‡±Å ‡∞µ‡±Ü‡∞Ø‡±ç‡∞Ø‡±Å!</button>
                    <div class="seeds" id="seedsDisplay"></div>
                </div>
            </div>
            
            <!-- 5% Status Grid -->
            <div class="status-row">
                <div class="status-cell accumulated" id="accumulatedCell"></div>
                <div class="status-cell turn-sum" id="turnCell"></div>
                <div class="status-cell remaining" id="remainingCell"></div>
                <div class="status-cell message" id="messageCell"></div>
            </div>
            
            <!-- 50% Board -->
            <div class="board-row">
                <div class="board" id="gameBoard"></div>
            </div>
            
            <!-- 3% Footer -->
            <div class="footer">
                ¬© 2024 Ashta Chemma (‡∞Ö‡∞∑‡±ç‡∞ü‡∞æ ‡∞ö‡∞Æ‡±ç‡∞Æ‡∞æ) | Developed by Mahesh G & Dhana Lakshmi S
            </div>
        </div>

        <!-- Menu Modal -->
        <div class="modal" id="menuModal">
            <div class="modal-content">
                <span class="modal-close" onclick="closeModal('menuModal')">√ó</span>
                <h2>Menu</h2>
                <button onclick="closeModal('menuModal'); openModal('referenceModal')" style="width: 100%; padding: 15px; margin: 10px 0; background: #667eea; color: white; border: none; border-radius: 8px; font-size: 2vh; cursor: pointer;">üìñ Reference Guide</button>
                <button onclick="closeModal('menuModal'); openModal('historyModal')" style="width: 100%; padding: 15px; margin: 10px 0; background: #667eea; color: white; border: none; border-radius: 8px; font-size: 2vh; cursor: pointer;">üìú Roll History</button>
                <button onclick="closeModal('menuModal'); openModal('statusModal')" style="width: 100%; padding: 15px; margin: 10px 0; background: #667eea; color: white; border: none; border-radius: 8px; font-size: 2vh; cursor: pointer;">üë• Team Status</button>
            </div>
        </div>

        <!-- Reference Modal -->
        <div class="modal" id="referenceModal">
            <div class="modal-content">
                <span class="modal-close" onclick="closeModal('referenceModal')">√ó</span>
                <h2>Reference Guide</h2>
                <ul>
                    <li><strong>Asta (‡∞Ö‡∞∑‡±ç‡∞ü‡∞æ):</strong> All same color = 2 Chemmas</li>
                    <li><strong>Chemma (‡∞ö‡∞Æ‡±ç‡∞Æ‡∞æ):</strong> 4 whites = Extra turn</li>
                    <li><strong>Mudu (‡∞Æ‡±Ç‡∞°‡±Å):</strong> 3 whites</li>
                    <li><strong>Rendu (‡∞∞‡±Ü‡∞Ç‡∞°‡±Å):</strong> 2 whites</li>
                    <li><strong>Kinnu (‡∞ï‡∞ø‡∞®‡±ç‡∞®‡±Å):</strong> 1 white</li>
                </ul>
            </div>
        </div>

        <!-- History Modal -->
        <div class="modal" id="historyModal">
            <div class="modal-content">
                <span class="modal-close" onclick="closeModal('historyModal')">√ó</span>
                <h2>Roll History</h2>
                <div id="rollHistoryContent" style="font-size: 1.8vh;"></div>
            </div>
        </div>

        <!-- Status Modal -->
        <div class="modal" id="statusModal">
            <div class="modal-content">
                <span class="modal-close" onclick="closeModal('statusModal')">√ó</span>
                <h2>Teams Status</h2>
                <div id="teamsStatusModal"></div>
            </div>
        </div>

        <!-- Win Modal -->
        <div class="modal" id="winModal">
            <div class="modal-content win-modal" style="text-align: center;">
                <div style="font-size: 10vh;">üèÜ</div>
                <h2 id="winnerText"></h2>
                <p style="font-size: 2vh; margin: 2vh 0;">Congratulations!</p>
                <button onclick="location.reload()" style="padding: 15px 40px; background: #4CAF50; color: white; border: none; border-radius: 8px; font-size: 2vh; cursor: pointer;">Play Again</button>
            </div>
        </div>
    </div>

    <script>
        let gameState = {
            teams: [], currentTeamIndex: 0, currentPlayerIndex: 0,
            chemmasCount: 0, lastRoll: null, killedThisTurn: false,
            moveHistory: [], initialPositions: [], selectedPieceId: null, validDestinations: [],
            turnStartChemmas: 0, turnStartLastRoll: null, firstRollOfTurn: true,
            killedPieces: [], // Track all pieces killed this turn for rollback
            totalChemmasThisTurn: 0, allRollsThisTurn: [], // Track all rolls for display
            rollHistory: [] // Complete history of all rolls across all turns
        };

        const TEAM_COLORS = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12'];
        const TEAM_NAMES = ['Red', 'Blue', 'Green', 'Orange'];
        const START_POSITIONS = [[4, 2], [2, 4], [0, 2], [2, 0]];
        const PATHS = {
            '0,2': [[0,2], [0,1], [0,0], [1,0], [2,0], [3,0], [4,0], [4,1], [4,2], [4,3], [4,4], [3,4], [2,4], [1,4], [0,4], [0,3], [1,3], [2,3], [3,3], [3,2], [3,1], [2,1], [1,1], [1,2], [2,2]],
            '2,0': [[2,0], [3,0], [4,0], [4,1], [4,2], [4,3], [4,4], [3,4], [2,4], [1,4], [0,4], [0,3], [0,2], [0,1], [0,0], [1,0], [1,1], [1,2], [1,3], [2,3], [3,3], [3,2], [3,1], [2,1], [2,2]],
            '4,2': [[4,2], [4,3], [4,4], [3,4], [2,4], [1,4], [0,4], [0,3], [0,2], [0,1], [0,0], [1,0], [2,0], [3,0], [4,0], [4,1], [3,1], [2,1], [1,1], [1,2], [1,3], [2,3], [3,3], [3,2], [2,2]],
            '2,4': [[2,4], [1,4], [0,4], [0,3], [0,2], [0,1], [0,0], [1,0], [2,0], [3,0], [4,0], [4,1], [4,2], [4,3], [4,4], [3,4], [3,3], [3,2], [3,1], [2,1], [1,1], [1,2], [1,3], [2,3], [2,2]]
        };

        function generateTeamInputs() {
            const numTeams = parseInt(document.getElementById('numTeams').value);
            const playersPerTeam = parseInt(document.getElementById('playersPerTeam').value);
            
            if (numTeams < 2 || numTeams > 4 || playersPerTeam < 1 || playersPerTeam > 2) {
                alert('Invalid values! Teams: 2-4, Players: 1-2');
                return;
            }
            
            const setupDiv = document.getElementById('teamSetup');
            setupDiv.innerHTML = '<h3>Enter Team and Player Names</h3>';
            
            for (let i = 0; i < numTeams; i++) {
                const teamItem = document.createElement('div');
                teamItem.className = 'team-item';
                teamItem.innerHTML = `
                    <h4>Team ${i + 1}</h4>
                    <input type="text" id="teamName${i}" placeholder="Team Name" value="Team ${i + 1}">
                    ${Array.from({length: playersPerTeam}, (_, j) => 
                        `<input type="text" id="player${i}_${j}" placeholder="Player ${j + 1}" value="Player ${j + 1}" style="margin-top: 10px;">`
                    ).join('')}
                `;
                setupDiv.appendChild(teamItem);
            }
            
            setupDiv.classList.remove('hidden');
            document.getElementById('startBtn').classList.remove('hidden');
        }

        function startGame() {
            const numTeams = parseInt(document.getElementById('numTeams').value);
            const playersPerTeam = parseInt(document.getElementById('playersPerTeam').value);
            
            gameState.teams = [];
            
            // Use opposite corners for 2 teams: positions 0 and 2 (top-left and bottom-left)
            const selectedPositions = numTeams === 2 ? [0, 2] : numTeams === 3 ? [0, 1, 2] : [0, 1, 2, 3];
            
            for (let i = 0; i < numTeams; i++) {
                const teamName = document.getElementById(`teamName${i}`).value || `Team ${i + 1}`;
                const players = [];
                
                for (let j = 0; j < playersPerTeam; j++) {
                    const playerName = document.getElementById(`player${i}_${j}`).value || `Player ${j + 1}`;
                    players.push({ name: playerName, pandatam: false });
                }
                
                const [startRow, startCol] = START_POSITIONS[selectedPositions[i]];
                gameState.teams.push({
                    id: i,
                    name: teamName,
                    color: TEAM_COLORS[i],
                    players: players,
                    path: PATHS[`${startRow},${startCol}`],
                    pieces: [
                        { id: 'P', type: 'parent', pathIndex: 0, dead: false },
                        { id: 'C1', type: 'child', pathIndex: 0, dead: false },
                        { id: 'C2', type: 'child', pathIndex: 0, dead: false }
                    ]
                });
            }
            
            document.getElementById('setupScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.remove('hidden');
            
            initGame();
        }

        function initGame() {
            renderBoard();
            renderPieces();
            updateGameDisplay();
            clearStatusCells();
        }

        function renderBoard() {
            const board = document.getElementById('gameBoard');
            board.innerHTML = '';
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < 5; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    if (row === 2 || col === 2) cell.classList.add('safe');
                    if (row === 2 && col === 2) cell.classList.add('win');
                    cell.addEventListener('click', () => handleCellClick(row, col));
                    board.appendChild(cell);
                }
            }
            renderPieces();
        }

        function renderPieces() {
            document.querySelectorAll('.pieces-on-cell').forEach(el => el.remove());
            gameState.teams.forEach(team => {
                team.pieces.forEach(piece => {
                    if (!piece.dead) {
                        const [row, col] = team.path[piece.pathIndex];
                        const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                        let piecesDiv = cell.querySelector('.pieces-on-cell');
                        if (!piecesDiv) {
                            piecesDiv = document.createElement('div');
                            piecesDiv.className = 'pieces-on-cell';
                            cell.appendChild(piecesDiv);
                        }
                        const pieceEl = document.createElement('div');
                        pieceEl.className = `piece team-color-${team.id} ${piece.type}`;
                        pieceEl.textContent = piece.id;
                        pieceEl.dataset.teamId = team.id;
                        pieceEl.dataset.pieceId = piece.id;
                        pieceEl.addEventListener('click', (e) => {
                            e.stopPropagation();
                            handlePieceClick(team.id, piece.id);
                        });
                        piecesDiv.appendChild(pieceEl);
                    }
                });
            });
        }

        const ROLL_NAMES = {
            'asta': { english: 'Asta', telugu: '‡∞Ö‡∞∑‡±ç‡∞ü‡∞æ' },
            'chemma': { english: 'Chemma', telugu: '‡∞ö‡∞Æ‡±ç‡∞Æ‡∞æ' },
            3: { english: 'Mudu', telugu: '‡∞Æ‡±Ç‡∞°‡±Å' },
            2: { english: 'Rendu', telugu: '‡∞∞‡±Ü‡∞Ç‡∞°‡±Å' },
            1: { english: 'Kinnu', telugu: '‡∞ï‡∞ø‡∞®‡±ç‡∞®‡±Å' }
        };

        function rollDice() {
            const seeds = [];
            let whiteCount = 0;
            for (let i = 0; i < 5; i++) {
                const isWhite = Math.random() > 0.5;
                seeds.push(isWhite);
                if (isWhite) whiteCount++;
            }

            const seedsDisplay = document.getElementById('seedsDisplay');
            seedsDisplay.innerHTML = '';
            
            // Get actual circle dimensions
            const circleRect = seedsDisplay.getBoundingClientRect();
            const circleWidth = circleRect.width;
            const circleHeight = circleRect.height;
            const seedWidth = circleWidth * 0.18;
            const seedHeight = circleHeight * 0.25;
            
            const positions = generateNonOverlappingPositions(5, circleWidth, seedWidth, seedHeight);
            
            seeds.forEach((isWhite, index) => {
                const seed = document.createElement('div');
                seed.className = `seed ${isWhite ? 'white' : 'black'}`;
                seed.style.left = positions[index].x + 'px';
                seed.style.top = positions[index].y + 'px';
                seed.style.transform = `rotate(${Math.random() * 360}deg)`;
                seedsDisplay.appendChild(seed);
            });

            let rollName, rollValue;
            if (whiteCount === 5 || whiteCount === 0) { rollName = 'asta'; rollValue = 'asta'; }
            else if (whiteCount === 4) { rollName = 'chemma'; rollValue = 'chemma'; }
            else if (whiteCount === 3) { rollName = 3; rollValue = 3; }
            else if (whiteCount === 2) { rollName = 2; rollValue = 2; }
            else { rollName = 1; rollValue = 1; }

            if (rollValue === 'asta') {
                gameState.chemmasCount += 2;
                gameState.totalChemmasThisTurn += 2;
            } else if (rollValue === 'chemma') {
                gameState.chemmasCount += 1;
                gameState.totalChemmasThisTurn += 1;
            }
            
            gameState.lastRoll = { name: rollName, value: rollValue };
            gameState.allRollsThisTurn.push({ name: rollName, value: rollValue });
            
            // Add to complete history
            const team = gameState.teams[gameState.currentTeamIndex];
            const player = team.players[gameState.currentPlayerIndex];
            gameState.rollHistory.push({
                teamName: team.name,
                playerName: player.name,
                roll: `${ROLL_NAMES[rollName].english} (${ROLL_NAMES[rollName].telugu})`,
                timestamp: new Date().toLocaleTimeString()
            });
            updateRollHistory();
            
            // Show accumulated rolls
            updateAccumulatedDisplay();

            // Check if this roll actually enables any moves
            if (rollValue === 'asta' || rollValue === 'chemma') {
                if (canMakeAnyMove()) {
                    showMessage('Extra turn! Roll again or wait.');
                } else {
                    // No valid moves possible, proceed to play
                    document.getElementById('rollBtn').disabled = true;
                    if (gameState.firstRollOfTurn) {
                        saveInitialPositions();
                        gameState.firstRollOfTurn = false;
                    }
                    showTurnSummary();
                    setTimeout(() => processAllRolls(), 1000);
                }
            } else {
                document.getElementById('rollBtn').disabled = true;
                if (gameState.firstRollOfTurn) {
                    saveInitialPositions();
                    gameState.firstRollOfTurn = false;
                }
                showTurnSummary();
                setTimeout(() => processAllRolls(), 1000);
            }
        }

        function generateNonOverlappingPositions(count, circleSize, itemWidth, itemHeight) {
            const positions = [];
            // 80% of the circle radius
            const maxRadius = (circleSize / 2) * 0.8;
            const centerX = (circleSize - itemWidth) / 2;
            const centerY = (circleSize - itemHeight) / 2;
            const minDistance = Math.max(itemWidth, itemHeight) * 0.4;
            
            for (let i = 0; i < count; i++) {
                let attempts = 0;
                let pos;
                
                do {
                    const angle = Math.random() * Math.PI * 2;
                    // Random distance within 80% radius
                    const dist = Math.random() * maxRadius;
                    pos = {
                        x: centerX + Math.cos(angle) * dist,
                        y: centerY + Math.sin(angle) * dist
                    };
                    attempts++;
                } while (attempts < 50 && positions.some(p => 
                    Math.sqrt(Math.pow(p.x - pos.x, 2) + Math.pow(p.y - pos.y, 2)) < minDistance
                ));
                
                positions.push(pos);
            }
            
            return positions;
        }

        function canConsumeAllValues(team) {
            // Check if there's any combination of moves that uses ALL accumulated values
            const totalChemmas = gameState.chemmasCount;
            const lastRoll = gameState.lastRoll;
            
            // Try to find if we can use all values
            function tryAllCombinations(remainingChemmas, remainingLastRoll, piecesState) {
                // Success: consumed everything
                if (remainingChemmas === 0 && !remainingLastRoll) {
                    return true;
                }
                
                // Try each piece
                for (let i = 0; i < piecesState.length; i++) {
                    const piece = piecesState[i];
                    if (piece.dead || piece.pathIndex >= team.path.length - 1) continue;
                    
                    // Try using different amounts of chemmas
                    const stepsPerChemma = piece.type === 'parent' ? 2 : 4;
                    
                    for (let chemmasToUse = 0; chemmasToUse <= remainingChemmas; chemmasToUse++) {
                        for (let useBase = 0; useBase <= (remainingLastRoll ? 1 : 0); useBase++) {
                            const baseSteps = piece.type === 'parent' && remainingLastRoll && remainingLastRoll.value === 2 ? 1 
                                : piece.type === 'child' && remainingLastRoll ?
                                  (remainingLastRoll.value === 1 ? 1 : remainingLastRoll.value === 2 ? 2 : remainingLastRoll.value === 3 ? 3 : 0)
                                : 0;
                            
                            if (chemmasToUse === 0 && useBase === 0) continue;
                            
                            const steps = (chemmasToUse * stepsPerChemma) + (useBase * baseSteps);
                            const newIndex = piece.pathIndex + steps;
                            
                            if (newIndex > team.path.length - 1) continue;
                            
                            // Check if valid move
                            const [newRow, newCol] = team.path[newIndex];
                            let valid = true;
                            
                            if (!isSafeZone(newRow, newCol)) {
                                const existing = getPieceAtForState(newRow, newCol, piecesState);
                                if (existing && (existing.teamId === team.id || existing.type !== piece.type)) {
                                    valid = false;
                                }
                            }
                            
                            if (valid) {
                                // Try this move
                                const newPiecesState = piecesState.map((p, idx) => 
                                    idx === i ? { ...p, pathIndex: newIndex } : { ...p }
                                );
                                
                                const newRemainingChemmas = remainingChemmas - chemmasToUse;
                                const newRemainingLastRoll = useBase > 0 ? null : remainingLastRoll;
                                
                                if (tryAllCombinations(newRemainingChemmas, newRemainingLastRoll, newPiecesState)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                
                return false;
            }
            
            const initialPiecesState = team.pieces.map(p => ({ 
                id: p.id, 
                type: p.type, 
                pathIndex: p.pathIndex, 
                dead: p.dead,
                teamId: team.id
            }));
            
            return tryAllCombinations(totalChemmas, lastRoll, initialPiecesState);
        }

        function getPieceAtForState(row, col, piecesState) {
            for (let piece of piecesState) {
                if (!piece.dead) {
                    const team = gameState.teams.find(t => t.id === piece.teamId);
                    const [pRow, pCol] = team.path[piece.pathIndex];
                    if (pRow === row && pCol === col) return piece;
                }
            }
            return null;
        }

        function updateRollHistory() {
            const historyDiv = document.getElementById('rollHistoryContent');
            historyDiv.innerHTML = '';
            
            const currentTeam = gameState.teams[gameState.currentTeamIndex];
            
            const recentHistory = gameState.rollHistory.slice(-20).reverse();
            recentHistory.forEach(entry => {
                const entryDiv = document.createElement('div');
                entryDiv.style.padding = '1vh';
                entryDiv.style.margin = '0.5vh 0';
                entryDiv.style.borderLeft = entry.teamName === currentTeam.name ? '4px solid #4CAF50' : '4px solid #ddd';
                entryDiv.style.background = entry.teamName === currentTeam.name ? '#e8f5e9' : '#f8f9fa';
                entryDiv.style.borderRadius = '4px';
                entryDiv.style.fontSize = '1.8vh';
                entryDiv.innerHTML = `<strong>${entry.teamName}</strong> - ${entry.playerName}: ${entry.roll} <span style="float: right; font-size: 1.4vh; color: #999;">${entry.timestamp}</span>`;
                historyDiv.appendChild(entryDiv);
            });
        }

        function updateAccumulatedDisplay() {
            const cell = document.getElementById('accumulatedCell');
            let text = '';
            const items = [];
            
            if (gameState.totalChemmasThisTurn > 0) {
                items.push(`${gameState.totalChemmasThisTurn} ‡∞ö‡∞Æ‡±ç‡∞Æ‡∞æ`);
            }
            
            const nonChemmaRolls = gameState.allRollsThisTurn.filter(r => r.value !== 'asta' && r.value !== 'chemma');
            nonChemmaRolls.forEach(r => {
                items.push(ROLL_NAMES[r.name].telugu);
            });
            
            text = 'Total: ' + (items.length > 0 ? items.join(' + ') : '-');
            cell.textContent = text;
        }

        function canMakeAnyMove() {
            const team = gameState.teams[gameState.currentTeamIndex];
            const player = team.players[gameState.currentPlayerIndex];
            
            // If no pandatam yet, chemma/asta always allows more rolls
            if (!player.pandatam) return true;
            
            // Check if can revive any dead piece
            const deadParent = team.pieces.find(p => p.type === 'parent' && p.dead);
            const deadChildren = team.pieces.filter(p => p.type === 'child' && p.dead);
            
            if (deadParent && gameState.chemmasCount >= 2) return true;
            if (deadChildren.length > 0 && gameState.chemmasCount >= 1) return true;
            
            // Check if there's any valid move possible
            let hasAnyMove = false;
            for (let piece of team.pieces) {
                if (!piece.dead) {
                    const dests = getAllValidDestinationsForCheck(team, piece, gameState.chemmasCount, gameState.lastRoll);
                    if (dests.length > 0) {
                        hasAnyMove = true;
                        break;
                    }
                }
            }
            
            if (!hasAnyMove) return false;
            
            // CRITICAL: Check if we can actually consume all accumulated values
            // If we have too many chemmas/rolls for remaining moves, don't allow more rolls
            return canConsumeAllValues(team);
        }

        function getAllValidDestinationsForCheck(team, piece, chemmasCount, lastRoll) {
            const destinations = [];
            const stepsPerChemma = piece.type === 'parent' ? 2 : 4;
            const baseSteps = piece.type === 'parent' && lastRoll && lastRoll.value === 2 ? 1 
                            : piece.type === 'child' && lastRoll ? 
                              (lastRoll.value === 1 ? 1 : lastRoll.value === 2 ? 2 : lastRoll.value === 3 ? 3 : 0) 
                            : 0;
            
            // Check if ANY piece on the team can use the last roll value
            const canUseLastRoll = lastRoll && team.pieces.some(p => {
                if (p.dead) return false;
                const steps = p.type === 'parent' && lastRoll.value === 2 ? 1 
                            : p.type === 'child' ? 
                              (lastRoll.value === 1 ? 1 : lastRoll.value === 2 ? 2 : lastRoll.value === 3 ? 3 : 0) 
                            : 0;
                if (steps === 0) return false;
                const newIdx = p.pathIndex + steps;
                if (newIdx > team.path.length - 1 || p.pathIndex === team.path.length - 1) return false;
                const [r, c] = team.path[newIdx];
                if (!isSafeZone(r, c)) {
                    const existing = getPieceAt(r, c);
                    if (existing && (existing.team.id === team.id || existing.piece.type !== p.type)) return false;
                }
                return true;
            });
            
            // Try all combinations
            for (let chemmas = 0; chemmas <= chemmasCount; chemmas++) {
                for (let useBase = 0; useBase <= (baseSteps > 0 ? 1 : 0); useBase++) {
                    const steps = (chemmas * stepsPerChemma) + (useBase * baseSteps);
                    if (steps > 0) {
                        const dest = getDestinationForCheck(team, piece, steps, chemmas, useBase, canUseLastRoll);
                        if (dest) destinations.push(dest);
                    }
                }
            }
            
            return destinations;
        }

        function getDestinationForCheck(team, piece, steps, chemmasUsed, baseUsed, canUseLastRoll) {
            const newIndex = piece.pathIndex + steps;
            if (newIndex > team.path.length - 1 || piece.pathIndex === team.path.length - 1) return null;
            
            // Can't enter win position with Chemma ONLY if no piece can use last roll
            if (newIndex === team.path.length - 1 && chemmasUsed > 0 && !baseUsed && !canUseLastRoll) {
                return null;
            }
            
            const [newRow, newCol] = team.path[newIndex];
            if (!isSafeZone(newRow, newCol)) {
                const existing = getPieceAt(newRow, newCol);
                if (existing) {
                    if (existing.team.id === team.id) return null;
                    if (existing.piece.type !== piece.type) return null;
                }
            }
            
            return { row: newRow, col: newCol, steps, newIndex, chemmasUsed, baseUsed };
        }

        function saveInitialPositions() {
            // Save positions of ALL teams' pieces at start of turn
            gameState.initialPositions = gameState.teams.map(team => ({
                teamId: team.id,
                pieces: team.pieces.map(p => ({ 
                    id: p.id,
                    pathIndex: p.pathIndex, 
                    dead: p.dead 
                }))
            }));
            gameState.turnStartChemmas = gameState.chemmasCount;
            gameState.turnStartLastRoll = gameState.lastRoll;
            gameState.killedPieces = [];
        }

        function rollbackPositions() {
            // Restore ALL teams' pieces to their initial positions
            gameState.initialPositions.forEach(teamState => {
                const team = gameState.teams[teamState.teamId];
                teamState.pieces.forEach(pieceState => {
                    const piece = team.pieces.find(p => p.id === pieceState.id);
                    if (piece) {
                        piece.pathIndex = pieceState.pathIndex;
                        piece.dead = pieceState.dead;
                    }
                });
            });
            
            gameState.chemmasCount = gameState.turnStartChemmas;
            gameState.lastRoll = gameState.turnStartLastRoll;
            gameState.moveHistory = [];
            gameState.killedPieces = [];
            renderPieces();
            showTurnSummary();
        }

        function showTurnSummary() {
            const turnCell = document.getElementById('turnCell');
            const remainCell = document.getElementById('remainingCell');
            
            turnCell.textContent = `Current: ${gameState.lastRoll ? ROLL_NAMES[gameState.lastRoll.name].telugu : '-'}`;
            
            let text = '';
            const items = [];
            
            if (gameState.chemmasCount > 0) {
                items.push(`${gameState.chemmasCount} ‡∞ö‡∞Æ‡±ç‡∞Æ‡∞æ`);
            }
            if (gameState.lastRoll) {
                items.push(ROLL_NAMES[gameState.lastRoll.name].telugu);
            }
            
            text = 'Remaining: ' + (items.length > 0 ? items.join(' + ') : 'None');
            remainCell.textContent = text;
        }

        function processAllRolls() {
            const team = gameState.teams[gameState.currentTeamIndex];
            const player = team.players[gameState.currentPlayerIndex];

            if (!player.pandatam) {
                if (gameState.chemmasCount > 0) {
                    player.pandatam = true;
                    updateGameDisplay();
                }
            }
            
            // Update display to show revival options
            updateGameDisplay();
            findMovablePieces();
        }

        function findMovablePieces() {
            if (gameState.chemmasCount === 0 && !gameState.lastRoll) {
                if (gameState.killedThisTurn) {
                    gameState.killedThisTurn = false;
                    gameState.moveHistory = [];
                    gameState.firstRollOfTurn = true;
                    document.getElementById('rollBtn').disabled = false;
                    showMessage('Killed! Roll again!');
                } else {
                    nextTurn();
                }
                return;
            }

            const team = gameState.teams[gameState.currentTeamIndex];
            const player = team.players[gameState.currentPlayerIndex];
            
            // Check if player needs pandatam (but still allow revival)
            if (!player.pandatam) {
                // Check if can do pandatam or revive
                const deadPieces = team.pieces.filter(p => p.dead);
                if (deadPieces.length === 0 || gameState.chemmasCount === 0) {
                    showMessage('Need Chemma/Asta for Pandatam. Turn skipped!');
                    nextTurn();
                    return;
                }
                // Has dead pieces and chemmas - let them revive
                showMessage('Select a dead piece to revive or a piece to move');
                highlightMovablePieces([]);
                return;
            }

            const movablePieces = [];

            team.pieces.forEach(p => {
                if (!p.dead) {
                    const dests = getAllValidDestinations(team, p);
                    if (dests.length > 0) movablePieces.push(p);
                }
            });

            // Check if can revive
            const deadParent = team.pieces.find(p => p.type === 'parent' && p.dead);
            const deadChildren = team.pieces.filter(p => p.type === 'child' && p.dead);
            const canRevive = (deadParent && gameState.chemmasCount >= 2) || (deadChildren.length > 0 && gameState.chemmasCount >= 1);

            if (movablePieces.length === 0 && !canRevive) {
                // Complete deadlock - no moves and no revivals possible
                if (gameState.moveHistory.length > 0 || gameState.killedPieces.length > 0) {
                    // Try to let user undo manually first
                    const killMsg = gameState.killedPieces.length > 0 ? ` ${gameState.killedPieces.length} kill(s) will be undone!` : '';
                    showMessage(`DEADLOCK! Click moved piece to undo OR wait 3s for auto-rollback.${killMsg}`);
                    highlightMovedPieces();
                    
                    // Auto-rollback after 3 seconds
                    setTimeout(() => {
                        // Check if still stuck
                        if (gameState.moveHistory.length > 0 || gameState.killedPieces.length > 0) {
                            const killedCount = gameState.killedPieces.length;
                            showMessage(`Auto-rollback: All moves undone${killedCount > 0 ? `, ${killedCount} kill(s) restored` : ''}. Turn skipped!`);
                            rollbackPositions();
                            nextTurn();
                        }
                    }, 3000);
                } else {
                    showMessage('No valid moves. Turn skipped!');
                    rollbackPositions();
                    nextTurn();
                }
                return;
            }

            if (movablePieces.length === 0 && canRevive) {
                showMessage('No pieces can move. Revive a dead piece!');
                return;
            }

            highlightMovablePieces(movablePieces);
            showMessage('Select a piece to move' + (canRevive ? ' or revive a dead piece' : ''));
        }

        function highlightMovedPieces() {
            const team = gameState.teams[gameState.currentTeamIndex];
            document.querySelectorAll('.piece').forEach(p => p.classList.remove('selectable'));
            
            gameState.moveHistory.forEach(move => {
                const pieceEl = document.querySelector(`.piece[data-team-id="${team.id}"][data-piece-id="${move.pieceId}"]`);
                if (pieceEl) {
                    pieceEl.classList.add('selectable');
                    pieceEl.style.borderColor = '#ff9800';
                    pieceEl.addEventListener('click', (e) => {
                        e.stopPropagation();
                        rollbackPositions();
                        setTimeout(() => findMovablePieces(), 300);
                    }, { once: true });
                }
            });
        }

        function getAllValidDestinations(team, piece) {
            const destinations = [];
            const stepsPerChemma = piece.type === 'parent' ? 2 : 4;
            const baseSteps = piece.type === 'parent' && gameState.lastRoll && gameState.lastRoll.value === 2 ? 1 
                            : piece.type === 'child' && gameState.lastRoll ? 
                              (gameState.lastRoll.value === 1 ? 1 : gameState.lastRoll.value === 2 ? 2 : gameState.lastRoll.value === 3 ? 3 : 0) 
                            : 0;
            
            // Check if ANY piece on the team can use the last roll value
            const canUseLastRoll = gameState.lastRoll && team.pieces.some(p => {
                if (p.dead) return false;
                const steps = p.type === 'parent' && gameState.lastRoll.value === 2 ? 1 
                            : p.type === 'child' ? 
                              (gameState.lastRoll.value === 1 ? 1 : gameState.lastRoll.value === 2 ? 2 : gameState.lastRoll.value === 3 ? 3 : 0) 
                            : 0;
                if (steps === 0) return false;
                const newIdx = p.pathIndex + steps;
                if (newIdx > team.path.length - 1 || p.pathIndex === team.path.length - 1) return false;
                const [r, c] = team.path[newIdx];
                if (!isSafeZone(r, c)) {
                    const existing = getPieceAt(r, c);
                    if (existing && (existing.team.id === team.id || existing.piece.type !== p.type)) return false;
                }
                return true;
            });
            
            // Try all combinations - including using chemmas AND base together
            for (let chemmas = 0; chemmas <= gameState.chemmasCount; chemmas++) {
                // Try without base value
                if (chemmas > 0) {
                    const steps = chemmas * stepsPerChemma;
                    const dest = getDestination(team, piece, steps, chemmas, 0, canUseLastRoll);
                    if (dest && !destinations.some(d => d.row === dest.row && d.col === dest.col)) {
                        destinations.push(dest);
                    }
                }
                
                // Try with base value
                if (baseSteps > 0) {
                    const steps = (chemmas * stepsPerChemma) + baseSteps;
                    const dest = getDestination(team, piece, steps, chemmas, 1, canUseLastRoll);
                    if (dest && !destinations.some(d => d.row === dest.row && d.col === dest.col)) {
                        destinations.push(dest);
                    }
                }
            }
            
            // Also try using only the base value (no chemmas)
            if (baseSteps > 0) {
                const dest = getDestination(team, piece, baseSteps, 0, 1, canUseLastRoll);
                if (dest && !destinations.some(d => d.row === dest.row && d.col === dest.col)) {
                    destinations.push(dest);
                }
            }
            
            return destinations;
        }

        function getDestination(team, piece, steps, chemmasUsed, baseUsed, canUseLastRoll) {
            const newIndex = piece.pathIndex + steps;
            if (newIndex > team.path.length - 1 || piece.pathIndex === team.path.length - 1) return null;
            
            // Can't enter win position with Chemma ONLY if no piece can use last roll
            if (newIndex === team.path.length - 1 && chemmasUsed > 0 && !baseUsed && !canUseLastRoll) {
                return null;
            }
            
            const [newRow, newCol] = team.path[newIndex];
            if (!isSafeZone(newRow, newCol)) {
                const existing = getPieceAt(newRow, newCol);
                if (existing) {
                    if (existing.team.id === team.id) return null;
                    if (existing.piece.type !== piece.type) return null;
                }
            }
            
            return { row: newRow, col: newCol, steps, newIndex, chemmasUsed, baseUsed };
        }

        function isSafeZone(row, col) { return row === 2 || col === 2; }

        function getPieceAt(row, col) {
            for (let team of gameState.teams) {
                for (let piece of team.pieces) {
                    if (!piece.dead) {
                        const [pRow, pCol] = team.path[piece.pathIndex];
                        if (pRow === row && pCol === col) return { team, piece };
                    }
                }
            }
            return null;
        }

        function highlightMovablePieces(pieces) {
            document.querySelectorAll('.piece').forEach(p => p.classList.remove('selectable'));
            const team = gameState.teams[gameState.currentTeamIndex];
            pieces.forEach(piece => {
                const pieceEl = document.querySelector(`.piece[data-team-id="${team.id}"][data-piece-id="${piece.id}"]`);
                if (pieceEl) pieceEl.classList.add('selectable');
            });
        }

        function handlePieceClick(teamId, pieceId) {
            if (teamId !== gameState.currentTeamIndex) return;
            
            const team = gameState.teams[teamId];
            const piece = team.pieces.find(p => p.id === pieceId);
            if (!piece || piece.dead) return;

            const destinations = getAllValidDestinations(team, piece);
            if (destinations.length === 0) {
                showMessage('No valid moves for this piece');
                return;
            }

            // Allow reselecting pieces - clear previous selection
            gameState.selectedPieceId = pieceId;
            gameState.validDestinations = destinations;

            if (destinations.length === 1) {
                movePiece(piece, destinations[0]);
            } else {
                showValidDestinations();
            }
        }

        function showValidDestinations() {
            document.querySelectorAll('.cell').forEach(c => c.classList.remove('valid-dest'));
            document.querySelectorAll('.piece').forEach(p => p.classList.remove('selectable'));
            
            gameState.validDestinations.forEach(d => {
                const cell = document.querySelector(`.cell[data-row="${d.row}"][data-col="${d.col}"]`);
                cell.classList.add('valid-dest');
            });
            
            // Re-highlight all movable pieces
            const team = gameState.teams[gameState.currentTeamIndex];
            team.pieces.forEach(p => {
                if (!p.dead) {
                    const dests = getAllValidDestinations(team, p);
                    if (dests.length > 0) {
                        const pieceEl = document.querySelector(`.piece[data-team-id="${team.id}"][data-piece-id="${p.id}"]`);
                        if (pieceEl) pieceEl.classList.add('selectable');
                    }
                }
            });
            
            showMessage(`${gameState.selectedPieceId}: Select destination`);
        }

        function handleCellClick(row, col) {
            if (!gameState.selectedPieceId) return;
            
            const dest = gameState.validDestinations.find(d => d.row === row && d.col === col);
            if (!dest) return;
            
            const team = gameState.teams[gameState.currentTeamIndex];
            const piece = team.pieces.find(p => p.id === gameState.selectedPieceId);
            if (piece) {
                movePiece(piece, dest);
            }
        }

        function movePiece(piece, dest) {
            const team = gameState.teams[gameState.currentTeamIndex];
            
            // Animate movement along path
            animatePieceMovement(team, piece, dest.newIndex, () => {
                // After animation completes
                piece.pathIndex = dest.newIndex;
                
                // Save move for history tracking
                gameState.moveHistory.push({
                    pieceId: piece.id,
                    oldIndex: dest.newIndex - dest.steps,
                    newIndex: dest.newIndex,
                    chemmasUsed: dest.chemmasUsed,
                    baseUsed: dest.baseUsed
                });

                if (dest.chemmasUsed > 0) {
                    gameState.chemmasCount -= dest.chemmasUsed;
                }
                if (dest.baseUsed > 0) {
                    gameState.lastRoll = null;
                }
                
                // Update displays - accumulated stays same, remaining changes
                showTurnSummary();

                gameState.selectedPieceId = null;
                gameState.validDestinations = [];
                document.querySelectorAll('.cell').forEach(c => c.classList.remove('valid-dest'));
                document.querySelectorAll('.piece').forEach(p => p.classList.remove('selectable'));

                renderPieces();

                const killed = checkForKill(team, piece, dest.row, dest.col);
                if (killed) {
                    gameState.killedThisTurn = true;
                }

                // Check for win - but only if all values are consumed
                if (team.pieces.every(p => p.pathIndex === team.path.length - 1)) {
                    if (gameState.chemmasCount === 0 && !gameState.lastRoll) {
                        document.getElementById('winnerText').textContent = `${team.name} Wins!`;
                        document.getElementById('winModal').classList.add('show');
                        return;
                    } else {
                        // Can't win with remaining values
                        showMessage(`Can't win with remaining values: ${gameState.chemmasCount} ‡∞ö‡∞Æ‡±ç‡∞Æ‡∞æ${gameState.lastRoll ? ' + ' + ROLL_NAMES[gameState.lastRoll.name].telugu : ''}. Invalid turn!`);
                        setTimeout(() => {
                            rollbackPositions();
                            nextTurn();
                        }, 2000);
                        return;
                    }
                }

                updateGameDisplay();
                setTimeout(() => findMovablePieces(), 500);
            });
        }

        function animatePieceMovement(team, piece, targetIndex, callback) {
            const startIndex = piece.pathIndex;
            const steps = targetIndex - startIndex;
            
            if (steps <= 0) {
                callback();
                return;
            }

            let currentStep = 0;
            
            function animateStep() {
                if (currentStep >= steps) {
                    callback();
                    return;
                }
                
                currentStep++;
                piece.pathIndex = startIndex + currentStep;
                renderPieces();
                
                setTimeout(animateStep, 200); // 200ms per step
            }
            
            animateStep();
        }

        function checkForKill(attackTeam, attackPiece, row, col) {
            if (isSafeZone(row, col)) return false;
            let killed = false;
            gameState.teams.forEach(defTeam => {
                if (defTeam.id !== attackTeam.id) {
                    defTeam.pieces.forEach(defPiece => {
                        if (!defPiece.dead) {
                            const [defRow, defCol] = defTeam.path[defPiece.pathIndex];
                            if (defRow === row && defCol === col && attackPiece.type === defPiece.type) {
                                // Track this kill for potential rollback
                                gameState.killedPieces.push({
                                    teamId: defTeam.id,
                                    pieceId: defPiece.id,
                                    pathIndex: defPiece.pathIndex
                                });
                                
                                defPiece.dead = true;
                                defPiece.pathIndex = 0;
                                killed = true;
                                renderPieces();
                                updateGameDisplay();
                            }
                        }
                    });
                }
            });
            return killed;
        }

        function revivePiece(teamId, pieceId) {
            console.log('revivePiece called', teamId, pieceId, 'chemmas:', gameState.chemmasCount);
            
            // Only allow revival for current team during their turn
            if (teamId !== gameState.currentTeamIndex) {
                showMessage('Not your turn!');
                return;
            }
            
            const team = gameState.teams[teamId];
            const piece = team.pieces.find(p => p.id === pieceId);
            
            if (!piece) {
                showMessage('Piece not found');
                console.log('Piece not found:', pieceId);
                return;
            }
            
            if (!piece.dead) {
                showMessage('Piece is not dead');
                console.log('Piece not dead:', piece);
                return;
            }

            const cost = piece.type === 'parent' ? 2 : 1;
            if (gameState.chemmasCount < cost) {
                showMessage(`Need ${cost} Chemma${cost > 1 ? 's' : ''} to revive`);
                console.log('Not enough chemmas. Need:', cost, 'Have:', gameState.chemmasCount);
                return;
            }

            // Revive the piece
            piece.dead = false;
            piece.pathIndex = 0;
            gameState.chemmasCount -= cost;
            
            console.log('Revived', pieceId, 'new state:', piece);
            
            showTurnSummary();
            renderPieces();
            updateGameDisplay();
            showMessage(`${piece.id} revived! Now at origin.`);
            
            // Continue with moves after revival
            setTimeout(() => findMovablePieces(), 500);
        }

        function nextTurn() {
            const currentTeam = gameState.teams[gameState.currentTeamIndex];
            gameState.currentPlayerIndex++;
            if (gameState.currentPlayerIndex >= currentTeam.players.length) {
                gameState.currentPlayerIndex = 0;
                gameState.currentTeamIndex = (gameState.currentTeamIndex + 1) % gameState.teams.length;
            }

            gameState.chemmasCount = 0;
            gameState.lastRoll = null;
            gameState.killedThisTurn = false;
            gameState.moveHistory = [];
            gameState.killedPieces = [];
            gameState.firstRollOfTurn = true;
            gameState.totalChemmasThisTurn = 0;
            gameState.allRollsThisTurn = [];
            document.getElementById('rollBtn').disabled = false;
            document.getElementById('seedsDisplay').innerHTML = '';
            clearStatusCells();
            updateGameDisplay();
        }

        function toggleCollapse(header) {
            header.classList.toggle('collapsed');
            const content = header.nextElementSibling;
            content.classList.toggle('hidden');
        }

        function openModal(modalId) {
            document.getElementById(modalId).classList.add('show');
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('show');
        }

        function updateGameDisplay() {
            const team = gameState.teams[gameState.currentTeamIndex];
            const player = team.players[gameState.currentPlayerIndex];

            document.getElementById('currentTurnInfo').innerHTML = `
                <h3 style="color: ${team.color};">${team.name}</h3>
                <p style="font-size: 18px;"><strong>${player.name}</strong></p>
                <p style="font-size: 14px; color: #666;">‡∞™‡∞Ç‡∞ü ‡∞™‡∞Ç‡∞°‡∞æ‡∞µ‡∞æ?: ${player.pandatam ? '<span style="color: green;">‚úì</span>' : '<span style="color: red;">‚úó</span>'}</p>
            `;

            const statusDiv = document.getElementById('teamsStatusModal');
            statusDiv.innerHTML = '';
            gameState.teams.forEach(t => {
                const isCurrentTeam = t.id === team.id;
                
                const teamDiv = document.createElement('div');
                teamDiv.style.marginBottom = '2vh';
                teamDiv.style.padding = '2vh';
                teamDiv.style.borderRadius = '8px';
                teamDiv.style.background = isCurrentTeam ? '#e8f5e9' : '#f8f9fa';
                teamDiv.style.border = isCurrentTeam ? '3px solid #4CAF50' : '1px solid #ddd';
                
                let piecesHTML = '';
                t.pieces.forEach(p => {
                    const pos = t.path[p.pathIndex];
                    const atWin = p.pathIndex === t.path.length - 1;
                    const status = p.dead ? 'üíÄ Dead' : atWin ? 'üèÜ WIN' : `üìç (${pos[0]},${pos[1]})`;
                    piecesHTML += `<div style="padding: 1vh; margin: 0.5vh 0; background: white; border-radius: 5px; border-left: 4px solid ${t.color}; font-size: 1.8vh;">${p.id}: ${status}</div>`;
                });
                
                teamDiv.innerHTML = `
                    <h3 style="color: ${t.color}; margin-bottom: 1vh; font-size: 2.5vh;">${t.name} ${isCurrentTeam ? '(Playing)' : ''}</h3>
                    <div style="font-size: 1.6vh; color: #666; margin-bottom: 1vh;">
                        ${t.players.map((p, i) => 
                            p.name + ' ‡∞™‡∞Ç‡∞ü: ' + (p.pandatam ? '<span style="color: green;">‚úì</span>' : '<span style="color: red;">‚úó</span>')
                        ).join(' | ')}
                    </div>
                    ${piecesHTML}
                `;
                statusDiv.appendChild(teamDiv);
            });
            
            // Update dead pieces display
            updateDeadRevivalDisplay();
        }

        function showMessage(msg) {
            document.getElementById('messageBox').textContent = msg;
            document.getElementById('messageBox').classList.remove('hidden');
        }
        function showMessage(msg) {
            document.getElementById('messageCell').textContent = msg;
        }

        function openMenuModal() {
            openModal('menuModal');
        }

        function openModal(modalId) {
            document.getElementById(modalId).classList.add('show');
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('show');
        }

        function updateDeadRevivalDisplay() {
            const revivalRow = document.getElementById('deadRevivalRow');
            const currentTeam = gameState.teams[gameState.currentTeamIndex];
            
            const deadPieces = currentTeam.pieces.filter(p => p.dead);
            const revivableParent = deadPieces.find(p => p.type === 'parent' && gameState.chemmasCount >= 2);
            const revivableChildren = deadPieces.filter(p => p.type === 'child' && gameState.chemmasCount >= 1);
            
            if (revivableParent || revivableChildren.length > 0) {
                revivalRow.innerHTML = '';
                
                if (revivableParent) {
                    const btn = document.createElement('div');
                    btn.className = 'revival-btn';
                    btn.textContent = `‚ü≥ Revive ${revivableParent.id}`;
                    btn.onclick = () => revivePiece(currentTeam.id, revivableParent.id);
                    revivalRow.appendChild(btn);
                }
                
                revivableChildren.forEach(child => {
                    const btn = document.createElement('div');
                    btn.className = 'revival-btn';
                    btn.textContent = `‚ü≥ Revive ${child.id}`;
                    btn.onclick = () => revivePiece(currentTeam.id, child.id);
                    revivalRow.appendChild(btn);
                });
                
                revivalRow.classList.add('show');
            } else {
                revivalRow.classList.remove('show');
            }
        }

        function clearStatusCells() {
            document.getElementById('accumulatedCell').textContent = '-';
            document.getElementById('turnCell').textContent = '-';
            document.getElementById('remainingCell').textContent = '-';
            document.getElementById('messageCell').textContent = '-';
        }

    </script>
</body>
</html>
